
# Simple ingress with multiple rules

AWS Application load balancer is a reverse proxy that can route requests based on paths, headers and etc and we can take advantage of it with ingress on Kubernetes.

# How it works

Here [in this file](./2.ingress-multiple-rules.yaml) I added two ingresses resources that creates multiple rules in different ways.
The ingress named `basic-ingress-with-multiple-rules-1` creates rules based on host `AND` path. Like the first ingress, the `basic-ingress-with-multiple-rules-2` do the same thing but it uses the `condition` and `action` annotations which creates less rules because it uses the `OR` operator.


## Deeper into the manifests

### Priority

To define the rules priorities on an ALB, the alb controller will first evaluate the ingress `group.order` annotation or, if not set, determine it by the lexycal order of the ingres's namespace/name. After that, the rules defined on **each ingress will be evaluated by precedence**. The first rule in the rules list will have lower priority.

This an example of 3 ingresses with 3 rules each and the `group.order` annotation set and the resulting list of rules.

**Ingresses**
```
ingress: 1
group.order: 3
rules:
    host: api1.example.com
    paths: 
        - /api1/v1/sales
        - /api1/v2/sales
        - /api1/*
```
```
ingress: 2
group.order: 1
rules:
    host: api2.example.com
    paths: 
        - /api2/v1/customer
        - /api2/v2/customer
        - /api2/*
```
```
ingress: 3
group.order: 2
rules:
    host: api3.example.com
    paths: 
        - /api3/v1/report
        - /api3/v2/report
        - /api3/*
```
**Final rules list on alb**
1. if host `api2.example.com` and path `/api2/v1/customer` then redirect to...
2. if host `api2.example.com` and path `/api2/v2/customer` then redirect to...
3. if host `api2.example.com` and path `/api2/*` then redirect to...

4. if host `api3.example.com` and path `/api3/v1/report` then redirect to...
5. if host `api3.example.com` and path `/api3/v2/report` then redirect to...
6. if host `api3.example.com` and path `/api3/*` then redirect to...

7. if host `api1.example.com` and path `/api1/v1/sales` then redirect to...
8. if host `api1.example.com` and path `/api1/v2/sales` then redirect to...
9. if host `api1.example.com` and path `/api1/*` then redirect to...


### Rules evalution

1. `basic-ingress-with-multiple-rules-1` will create the following rules in the ALB:

    1. if `HOST` is `basic-ingress-with-multiple-rules.testingdomain.com` **AND** `PATH` is `/this/is/the/second/rule/*` then it will redirect to the TargetGroup (the service).

    2. if `HOST` is `basic-ingress-with-multiple-rules.testingdomain.com` **AND** `PATH` is `/this/is/a/long/path/and/is/the/first/in/the/list/*` then it will redirect to the TargetGroup (the service).

    3. if `HOST` is `basic-ingress-with-multiple-rules.testingdomain.com` **AND** `PATH` is `/last/rule*` then it will redirect to the TargetGroup (the service).


2. `basic-ingress-with-multiple-rules-2` will create the following rules in the ALB:

    1. if `HOST` is `basic-ingress-with-multiple-rules.testingdomain.com` **AND** `PATH` is `/like-the-first-service/*` OR `/similar-to-the-first-service/*` then it will redirect to the TargetGroup (defined in the `alb.ingress.kubernetes.io/actions.forward-jeferson` annotation).

    2. if `HOST` is `basic-ingress-with-multiple-rules.testingdomain.com` **AND** `PATH` is `/second-service/*` then it will redirect to the TargetGroup (the service)


#### Order matters

According to the [alb-load-balancer-controller documentation](https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/ingress/spec/), `pathType` is key in defining the order the rules will be created on the ALB, which also means the priority. This is important and critical when the ALB has multiple rules and if the order is incorrect it can route the request to the wrong service or return an unexpected response.

The alb-load-balancer-controller will create the rules according to the order that we set them in the ingrees definition so we must be careful when defining the rules. 

Actually, it's important to talk `pathType` while explaining the rule order. `pathType` determines how broad a ruleâ€™s match is. There are three pathTypes and we should follow this order when adding rules:

1. `pathType: Exact` - This matches the rule exactly the way it's written. The request will match only if the path is exactly `/first-service`. 
```
path: /first-service
pathType: Exact
```
2. `pathType: Prefix` - This matches the prefix and accepts anything after it (`/first-service/*`. So, always add the rule with the longest prefix first.

With the order like this, the request will never match `/api/first-service` because the first rule will match it always (`/api/*`)
```
path: /api/
pathType: Prefix

path: /api/first-service
pathType: Prefix
```

This is the proper order to add Prefix rules
```
path: /api/first-service
pathType: Prefix

path: /api/
pathType: Prefix
```

3. `pathType: ImplementationSpecific` - This is like a mix of `Prefix` and `Exact`. For each path it will add a rule with an `OR` condition. E.g:

1. If `PATH` is `/api` OR `/api/*` then...
2. If `PATH` is `/api/first-service` OR `/api/first-service/*` then...

So be careful, because like in this scenario, the `/api/first-service` will never reach the proper rule as `api/*` will always be matched.

```
path: /api
pathType: ImplementationSpecific

path: /api/first-service
pathType: ImplementationSpecific
```




